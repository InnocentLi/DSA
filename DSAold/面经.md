#### http 0.9 1.0 1.1 2.0 的区别

#### 0.9

http0.9是第一个版本的http协议，由于十分简单，现在已经过时，它只允许客户端发送一个get请求。在http0.9的时候就是无状态协议，每个事务独立处理，事务结束就释放这个连接，所以在0.9http的无状态协议就已经成型。它是由客户端发送一个get请求连接，web服务端返回所请求的内容，即使返回过程中有错误，也不会返回错误码。

#### 1.0

Http1.0是http的第二个版本，与第一个版本不同之处在于，http支持头域；这里支持post方法向web端提供数据，支持head，get，post方法；可以使用长连接，但是默认是短链接；支持缓存机制，身份认证

#### 1.1

相对于1.0来说，1.1它是默认为长连接的在1.1中有了keep-alive，一定程度上弥补了1.1的缺点；可以对请求设定范围，加入了range的功能，在1.0中不论客户端要什么，服务器端都会把所有内容返回个客户端，产生了资源的浪费；提供了host头域，由于一台服务器上可以有多个虚拟机，共享同一个ip地址，所以支持host头域，如果没有host头域会报告错误400；多了一些缓存字段；增加了一些错误通知，例如410某个资源被永久性删除

#### 2.0

在2.0中http的帧都用二进制编码；不再依赖多个tcp连接去处理更多的并发请求，而是可以多路复用，数据流都叉分成多个互不依赖的帧，这些帧可以交错，可以分优先级，最后再在另一端根据每个帧首部的流标识符把它们重新组合起来；头部压缩，在1.1中首部带有大量的信息，每次都要重新发送，2.0中通讯双发各自缓存一份首部字段表，避免重复传输；请求优先级

#### c++的特点

1. C++是C语言的超集。它既保持了C语言的简洁、高效和接近汇编语言等特点，又克服了C语言的缺点，其编译系统能检查更多的语法错误，因此，C++比C语言更安全。

2. C++保持了与C语言的兼容。绝大多数C语言程序可以不经修改直接在C++环境中运行，用C语言编写的众多库函数可以用于C++程序中。

3. 支持面向对象程序设计的特征。C++既支持面向过程的程序设计，又支持面向对象的程序设计。

4. C++程序在可重用性、可扩充性、可维护性和可靠性等方面都较C语言得到了提高，使其更适合开发大中型的系统软件和应用程序。

5. C++设计成静态类型、和C同样高效且可移植的多用途程序设计语言。

6. C++设计成直接的和广泛的支援多种程序设计风格（程序化程序设计、资料抽象化、面向对象程序设计、泛型程序设计）。

7. C++设计成给程序设计者更多的选择，即使可能导致程序设计者选择错误。

8. C++设计成尽可能与C兼容，籍此提供一个从C到C++的平滑过渡。

9. C++避免平台限定或没有普遍用途的特性。

10. C++不使用会带来额外开销的特性。

11. C++设计成无需复杂的程序设计环境。

#### static的作用

1.隐藏性:当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性

2.static的第二个作用是保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。

#### new和malloc的区别

![屏幕快照 2018-09-12 上午11.45.02](/Users/hanxu/Desktop/屏幕快照 2018-09-12 上午11.45.02.png)

#### socket通信的几个关键函数

Socket（）返回一个套接字
Bind（）服务器端绑定需要监听的端口
Listen（）监听端口
Connect（）客户端调用此函数与服务器建立连接
Accept（）服务器端调用此函数等待客户端的连接
Close（）关闭套接口，终止连接（同时终止数据传送的2个方向，读和写，TCP是全双工的，有时候仅需要关闭写，仍然可以读，用shutdown）
Shutdown（）关闭socket

#### vector和list的区别？

1.vector
    连续存储结构，每个元素在内存上是连续的；支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；相当于一个数组，但是与数组的区别为：内存空间的扩展。vector支持不指定vector大小的存储，但是数组的扩展需要程序员自己写。

扩充空间（不论多大）都应该这样做：
   （1）配置一块新空间
   （2）将旧元素一一搬往新址
   （3）把原来的空间释放还给系统

2.list
    非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。支持高效的随机插入/删除操作，但随机访问效率低下，且由于需要额外维护指针，开销也比较大。每一个结点都包括一个信息快Info、一个前驱指针Pre、一个后驱指针Post。可以不分配必须的内存大小方便的进行添加和删除操作。使用的是非连续的内存空间进行存储。
   优点：(1) 不使用连续内存完成动态操作。
               (2) 在内部方便的进行插入和删除操作
               (3) 可在两端进行push、pop
   缺点：(1) 不能进行内部的随机访问，即不支持[ ]操作符和vector.at()
               (2) 相对于verctor占用内存多

#### 客户端为什么不需要bind？

有连接的socket客户端通过调用Connect函数在socket数据结构中保存本地和远端信息，无须调用bind()，因为这种情况下只需知道目的机器的IP地址，而客户通过哪个端口与服务器建立连接并不需要关心，socket执行体为你的程序自动选择一个未被占用的端口，并通知你的程序数据什么时候打开端口。

1.需要在建连前就知道端口的话，需要 bind 
2.需要通过指定的端口来通讯的话，需要 bind

#### 什么是字节序？

大端小端

1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：

**1)大端模式：**

低地址 -----------------> 高地址
0x12  |  0x34  |  0x56  |  0x78

**2)小端模式：**

低地址 ------------------> 高地址
0x78  |  0x56  |  0x34  |  0x12

#### socket通信阻塞与非阻塞

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。

   事情一件件的做，做完一件返回一件，做不完不回复也不返回。

2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）

   当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

3. 阻塞，      就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。

   阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。

4. 非阻塞，  就是调用我（函数），我（函数）立即返回，通过select通知调用者

   非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。