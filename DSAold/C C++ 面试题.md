1.一个C程序的【执行】是从本程序的main函数

2.int类型的指针数组:	int *a[10]

```
int a[10];				为int类型的数组
```

```
int (*a)[10];			为int类型的数组的指针
```

```
int *a[10];				为int类型的指针的数组
```

```
int (*a[10])(int);		为函数指针的数组，[]有限级高于*，说明a是一个数组，数组元素的类型为函数指针 
```

3.声明纯虚函数的类【不能】实例化

4.如果要实现一个多线程(非MFC)程序, 选择多线程CRT, 创建线程的时候应该用【_beginthreadex】

5.c++ traits

(1)一个traits包括了enum、typedef、模板偏特化（template partial specialization）

(2)typedef定义了各个类的各自不同的类型定义

(3)模板偏特化用于实现各个类的不同功能

(4)当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同，traits会是一种很好的解决方案

6.选快希堆不稳（是不稳定的排序），堆归选基均不变（运行时间不发生变化，与初始状态无关）

7.在C的文件操作中，可以利用【fseek函数】进行【文件指针的随机定位】

8.基类的保护成员是其公有派生类的【保护】成员

9.

```c++

#include<iostream>
using namespace std;
	int main(){
		int i=100;
		cout.unsetf(ios::dec);//取消(unsetf)十进制(dec)表示
		cout.setf(ios::hex);//用十六进制(hex)表示
		cout<<i<<"\t";
		cout<<i<<"\t";
		cout.setf(ios::dec);//用十进制表示
		cout<<i<<"\t";
	return 0;
}
```

10.静态变量static在不同的实例中地址【一样】,他们储存在【全局】区域

static变量也称作静态变量，静态变量和非静态变量的区别是：

静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。

而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

静态变量，即类变量，实例共享，内存中唯一，存储在方法区当中

 11.执行 char str[10] = "Ch\nina";后，strlen(str) 的返回值是【6】，sizeof(str)是【7】

​	在strlen中\n是一位，但是大小sizeof是两位

##### ???

12.语句printf(“a\bre\’hi\’y\\\bou\n”);的输出结果是【re’hi’you】

首先要明确该字符串中包含的转义字符，”a \b re \’ hi \' y \\ \b ou \n”中的转义字符（带下划线的部分）共有6个，其中’\b’是退格符，输出时将光标往左边回退一个位置，

‘    \’    ’为单引号字符，’   \\    ’为\字符，’   \n  ’为回车换行符。

13.括号记得逗号算是逗号运算符，只取最右边的值

14重复多次 fclose 一个打开过一次的 FILE *fp 指针,【导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常】

15.局部变量存放在栈中，堆中存放的是new和malloc开辟出的，而程序中定义的常量存放在只读存储区

（1）从静态存储区域分配：

内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static变量等。

（2）在栈上分配：

在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

（3）从堆上分配：

即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。

一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。

16.

```c
void main() 
{ 
char *p,*q; 
p=(char *) malloc(sizeof (char)*20);q=p; 
scanf ("%s%s",p,q); printf ("%s %s\n",p,q); 
} 
```

当输入abc def时输出结果为def def

因为指针p和q都是指向动态分配的20个字节的内存单元，当使用scanf来读取输入的字符串到该内存块时，首先将abc存入到指针p所指的内存块，输入中的空格符，表示字符串输入结束，下一字符串def将存入到q所指的内存块，即原先的字符串abc将被覆盖掉。所以输出的结构就应是def def。

17.对象成员的表示方法与结构体变量成员的表示方法【不】相同

18.下列程序输出的结果是

```c
int a=21,b=11;
printf("%d\n",--a+b,--b+a);
```

printf（）函数是从右往左计算表达式的，所以计算两个表达式：--b+a,   b=10, a=21, 结果31（前缀自加自减，先自加自减再参与运算）									      --a+b,   a=20, b=10, 结果30

但输出时是从左往右输出的即输出--a+b的结果，30

【printf函数从右向左计算，从左向右输出】

19. C 语言程序中,若对函数类型未加显式说明,则函数的隐含说明类型为【int】

20. 下面程序输出的结果为

    ```c
    har s[]="abcde";
    printf("%d", s);//s的地址
    printf("%d", s[0]);//97
    printf("%s", s);//abcde
    printf("%s", &s[1]);//bcde
    printf("%s", &s[0]);//abcde
    printf("%c", s[0]);//a
    printf("%d\n",sizeof(float));//4
    ```

21.设p是指针变量,语句P ＝ NULL;等价于【p ＝ 0 ;】

 ’\0‘的ASCAll码为0,所以NULL等效于0

22. 只能使用成员函数重载的运算符有：=、()、[]、->、new、delete

23.

```c
int main(void)
{
	enum team { my , your = 9 , his , her = his + 3};//0     9    10   13
	printf("%d %d %d %d\n",my , your , his , her);
	return 0;
}
```

(1)两个或多个枚举常量可以具有相同的值；

(2)当没有为枚举常量指定值时，它的值比前一个常量的值大1（第一个枚举常量的值默认为0）；

(3)枚举常量遵循C语言的作用域规则。

24.友元函数没有this指针

25.int a=5,b=-5;printf(“%d,%d”),a%(-4),b%(-4));输出【1，-1】

除号的正负取舍和一般的算数一样，符号相同为正，相异为负

（-m)/n 和 m/(-n) 等于-(m/n)

  m%(-n) 等于m%n

  (-m)%n 等于-(m%n)

26.以下程序的输出结果为（ ）

```c
int i;

void prt( )
{ for(i=5;i<8;i++)    printf("%c",'*');
printf("\t");
}
main( )
{  for(i=5;i<=8;i++)  prt( );
}
```

全局变量 i main()中修改为i=5;

在 prt() 中执行循环后 修改后 i=8;

在main()中再次调用prt()时执行一次print("\t")，然后修改后 i=9;

 27.

```c
void main() { 
    char str[]="S\065AB"; 
    printf("\n%d", sizeof(str)); 
}
```

' \065 ' 为八进制数

S  \065  A  B  \0

28.由printf输出的数据都隐含【右】对齐

29. scanf和printf是C语言提供的输入和输出【函数】

30. 希尔排序又称“缩小增量排序”，即每趟只对相同增量距离的关键字进行比较，这与关键字序列初始有序或无序无关

31. 关键路径是AOE网中从源点到终点的最长路径

32.   (1)B树和B+树【不能】有效的支持顺序检索

      (2)B树和B+树都可用于文件的索引结构

      (3)B树和B+树都是平衡的多叉树

      (4)B树和B+树都能有效的支持随机检索

33.C 源程序中凡是行首以#标识的控制行都是预处理指令

34.WPS 中设置第二个窗口操作应按【F6】

35.

Vi编辑器中,怎样将字符AAA全部替换成yyy? 

vi/vim 中可以使用 ：s 命令来替换字符串。该命令有很多种不同细节使用方法，可以实现复杂的功能。

实现全部的AAA替换为yyy，也就是全局替换，需要加参数 g。 

因此全局替换命令为：:%s/源字符串/目的字符串/g

36在汉字库中查找汉字时，输入的是汉字的机内码，输出的是汉字的【字形码】

37.若X是二叉中序线索树中一个有左孩子的结点,且X不为根,则X的前驱为【X的左子树中最右的结点】

38.f(n) = O(g(n))	f(n)的阶不高于g(n)的阶

39.在UCDOS全拼输入方式中，在提示行上向前或向后翻页查找，要按键【-和=】

40.CPU能直接存取内存储器中的数据

41. 有n(n>0)个分支结点的满二叉树的深度是【log2(n+1)+1】

    分支就是树中除了叶子节点意外的其他节点就是分支节点。

    由于是满二叉树，所以高度应该在分支节点的高度上+1

42.对于任意一个图，从它的某个结点进行一次深度或广度优先遍历【不一定】可以访问到该图的每个顶点

​	连通图可以，不连通不可以

43.只要在无向有权图中存在1个环（回路）的权值之和为负值，我们就称此无向图存在“负权回路”下面哪个算法可以检验一个无向图是否存在负权回路【最短路径Bellman-Ford算法】

44.机内码每个字节最高位为1，国标码则为0

45.

**常用的溢出检测机制主要有进位判决法和双符号位判决法。**

**双符号位判决法采用两位表示符号，即00表示正号、11表示负号，则溢出时两个符号位就不一致了，从而可以判定发生了溢出。**

**假设X、Y分别两个加数符号位,Z为运算结果符号位。**

**当X=Y=00（两数同为正），而Z=01（结果为负）时，正溢出；**

**当X=Y=11（两数同为负），而Z=10（结果为正）时，负溢出.**

46. 用三叉链表作二叉树的存储结构，当二叉树中有n个结点时，有【n+2】个空指针

    三叉链表，每个节点有三个指针，左孩子，右孩子，父节点。

    对于有n个节点的树结构，有n-1条边，每条边是孩子节点指向父节点的指针，也是父节点指向孩子节点的孩子指针， 所以一共是2(n-1)个指针，总的指针就是3n-2(n-1)=n+2

47.类静态成员数据为该类所有对象共享，在该类对象被撤销时，静态成员并【不撤销】。

48.用户在网络上发布的任何“信息”，都应对其所产生的一切后果负【法律责任】

49.语言处理程序包括：汇编程序、编译程序和 【解释程序】

50.C语言数组定义时，下标必须为【常数】

51.n个结点的线索二叉树上含有的线索数为【n + 1】

​	每个结点有2个指针域（指向左孩子和右孩子），n个结点总共有2n个；

​	一个n个结点的树有n-1条边，那么线索数= 2n - (n-1) = n + 1.

52.一个无序的元素序列可以通过构造一棵二叉排序树而变成一个有序的元素序列

53.CCED 中块的定义用【F8】

54.为了实现主机和外设之间的信息传送，可以使用【传送指令】或【输入/输出指令】

55.若已包含标准库头文件及相关命名空间，则系统【不允许】用户重新定义标准库函数

56. 定义 函数 时，缺省函数的类型声明，则函数类型取缺省类型 【int】
57. 深度优先遍历判断图是否有环
58. 循环队列的相关条件和公式：    队尾指针是rear,队头是front，其中QueueSize为循环队列的最大长度
    (1)队空条件：rear==front   
    (2)队满条件：(rear+1) %QueueSIze==front   
    (3)计算队列长度：（rear-front+QueueSize）%QueueSize   
    (4)入队：（rear+1）%QueueSize   
    (5)出队：（front+1）%QueueSize
59. 二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域

60.构造函数不能为虚函数

61.将一个*递归算法*改为对应的*非递归算法*时，通常需要使用【栈】

62.带头结点head的单向*循环*链表L为空的判断条件是【head->next == head】

63.eclipse如果要查看变量，使用哪个快捷键【Ctrl+Shift+g】

64.二元查找树的任何结点的左右子树【都是】二元查找树

二元查找树:二元查找树是计算机用语，指一棵空树或者具有下列性质的二元树：若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二元查找树；没有键值相等的节点。

65.AOE网一定是有向无环图【拓扑排序】

66.线索化二叉树中某结点D，没有左孩子的主要条件是【D->ltag=1】

Itag为0时，指向该节点的左孩子，为1时指向该节点前驱

Rtag为0时，指向该节点的右孩子，为1时指向该节点后继

 67.动态RAM的特点是【每隔一定时间需要刷新】

68.某【带链的队列】初始状态为 front=rear=NULL 。经过一系列正常的入队与退队操作后， front=rear=10 。该队列中的元素个数为【1】

69.C++中32位单精度浮点数能表示的十进制有效数字是多少位

单精度浮点数的有效位数是7位。

双精度浮点数的有效位数是16位。

70.

析构函数做最后的“清场工作”，

一般当派生类对象从内存中撤销时，先调用派生类的析构函数，再调用基类析构函数；

但，若用new建立了临时对象，在用delete撤销对象是，系统会只执行基类的析构函数，而不执行派生类的析构函数。

如果将基类的析构函数声明为虚函数，由基类所有派生类的析构函数自动成为虚函数（即使析构函数名不同）。

将析构函数加上vitual，实现具体对象的 **动态关联** ，在运行阶段，先调用派生类析构，在调用基类析构

71.UML 是软件开发中的一个重要工具，它主要应用于哪种软件开发方法【基于对象的面向对象的方法】

72.IP数据报头采用【big_endian】字节序，在此字节序下从低地址到高地址0x1234的表示形式为 【0 0 0x12 0x34】

```
big_endian,0 0 0x12 0x34
```

其实 big endian 是指低地址存放最高有效字节（ MSB ），而 little endian 则是低地址存放最低有效字节（ LSB ）。 所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进 行传输。

73.用户程序中的输入、输出操作实际上是由【操作系统】完成

74.组合逻辑控制器和微程序控制器的主要区别在于【微操作信号发生器的构成方法不同】

75.

当派生类中不含对象成员时：

- 在创建派生类对象时,构造函数的执行顺序是：基类的构造函数 → 派生类的构造函数；
- 在撤消派生类对象时,析构函数的执行顺序是：派生类的析构函数 → 基类的析构函数。

当派生类中含有对象成员时：

- 在定义派生类对象时，构造函数的执行顺序：基类的构造函数 → 对象成员的构造函数 → 派生类的构造函数；
- 在撤消派生类对象时，析构函数的执行顺序：派生类的析构函数 → 对象成员的析构函数 → 基类的析构函数。

对象成员是包含在类中的对象

76.下列程序的输出结果是【4】【自增运算符++优先级大于指针*】

```c
int main() {
	int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, *p = a + 3;
	printf("%d", *++p);
	return 0;		
}
```

77.设系统中有 m 个同类资源数， n 为系统中的并发进程数，当 n 个进程共享 m 个互斥资源时，每个进程的最大需求数是 w ，试问下列情况下系统会死锁的是（    ）

要满足不等式【(w - 1) * n < m】

78.在 linux 下，如何查看物理内存的大小	【**cat /**proc/meminfo】





 




