1.从右往左读 碰到*读指向 碰到const读常量

​	int const *x；const int *x；x指向整型常量  常量指针

​	int *const x； x常量指向整型 指针常量

2.浮点型判断abs(x - 1.0) < epson，不然会无限循环

3.科学计数法:前面的数可以是整型或者浮点型 中间是E/e 后面的数字必须是整型

4.数值在c语言中只有三种表示形式 十进制，八进制0开头，十六进制0x

5.数组定义  a[]  [10 }只允许省略最高的一维

6.带头结点的单链表head为空的判定条件 head->next == NULL

​	如果是不带头结点的链表则是 head == NULL

7.链表的结构中，需要有【数据域】以及【指向自身的指针域】

8.int a[10] a[1]的地址:

a + 1；&a[0] + 1；(int*)&a+1； (int*)((char*)&a+sizeof(int))；
9. 顺序表:线性表，顺序表，链表【只要是链表就是线性表】，栈

10.对线性表进行折半查找时，要求线性表必须：以顺序方式存储，且结点按关键字有序排序

11.线性表是具有 n 个数据元素的有限序列(n>0)

12.下列关于数组与指针的区别:用运算符sizeof 可以计算出数组的容量（字节数）

​	(1)数组开辟后它的地址是不可变的；

​	(2)数组的sizeof是数组的大小，指针只有一个指针的sizeof；sizeof只能计算指针的容量

13.对一个具有n个元素的线性表，建立其有序单链表的时间复杂度为

​	应该是先排序，在构建链表，排序是O(nlogn)，构建链表是O(n) 

​	总的时间复杂度为O(nlogn)+O(n)=O(nlog2n)

14.广义表:取tail结果加个括号，取head直接取结果即可

##### 15.线性结构：是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。[有明确的前后顺序]

**常用的线性结构有：线性表，栈，队列，双队列，数组，串。**

##### **非线性结构**：中各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。根据关系的不同，可分为层次结构和群结构。

常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图。（其中多维数组是由多个一维数组组成的，所以不再是线性结构）

例如，二维数组就是一种非线性结构**（因为是一对多的关系了：a[0]对应两个：a[0]{0} ,a[0][1})

16.一个广义表可以为其他广义表所共享

​	广义表有如下三个特性：

​	(1)层次性：广义表的元素可以是子表，而子表的元素还可以是子表，由此，广义表是一个多层次的结构； 

​	(2)共享性：广义表可为其他表所共享。

​	(3) 递归表：广义表可以是其自身的一个子表。

17.

​	折半查找属于随机访问特性 链表不行

​	堆排序也不能用链表 因为调整堆时没法随机访问底层孩子节点

​	快速排序可以链表

​	归并排序可用链表

​	基数排序可用链表

​	插入排序链表比数组要快一些 减少移动次数

18.静态局部变量只对定义它的函数体始终可见，函数体执行完过后虽然还存在，但是无法被其他的使用了。

 19.以下选项中，对基本类型相同的指针变量不能进行运算的运算符是（）。

​		A.+			B.-			C.=			D.==

 A错误，因为两个地址相加无意义也可能越界，所以规定不允许指针相加。 其他的都很好理解，B选项，可以求出两个数据元素储存位置之间的相隔同数据类型的元素个数，C选项，赋值，很好理解，D选项，判断两指针所指向的是否是同一数据元素

20.一个c语言程序由若干函数组成；一个c语言项目由若干程序组成；

21.

```c
#include "stdio.h"

int func(int x, int y) {
    return (x + y);
}

int main() {
    int a = 1, b = 2, c = 3, d = 4, e = 5;
    printf(" %d\n", func((a + b, b + c, c + a), (d, e)));
    return 0;

}
```

注意括号中逗号运算符返回值是最后的表达式的值，题中第一个参数为c+a=4, 后一个参数为e=5,所以结果为9。

22.C 源程序中凡是行首以#标识的控制行都是预处理指令

23.switch--case 没有break；不跳出；

24.预处理可以包含1.宏定义指令2.条件编译指令3.头文件包含指令4.编译程序可以识别的特殊符号

25.m:矩阵行数 n:矩阵列数 X:起始地址 k:每个元素占地址量 求[i,j]的地址Y 以行为主存时:(x加上从第一个横着数到[i,j]有多少个元素[不算第一个]乘以k) Y＝X+(n(i-1)+j-1)*k 以列为主存时:(同上，竖着数) Y＝X+(m(j-1)+i-1)*k 本题数据带入 Y＝X+(8*(8-1)+5-1)*3=X+180

26.用户标识符【数字、下划线、英文字符】


(1).标识符的第一个字符必须是字母或下划线，后面的字符可以是字母、数字或下划线，不能为其它字符。
(2).标识符的长度可以是一个或多个字符，最长不允许超过32个字符。
(3).标识符不能和C语言的关键字相同，也不能和用户自定义的函数或C语言库函数同名。


27.实参和型参之间是【单项值传递】

28.static静态局部变量只对定义它的函数体始终可见，函数体执行完过后虽然还存在，但是无法被其他的使用了

29.

%d:指参数以十进制整型输入or输出；

%f:浮点数输入or输出(还有%1.2f 等，表示限定小数点前后的位数)

 %u:无符号整数 

%x:十六进制

%o:八进制。

30. 小端大端

    1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。

    2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。

31.%%是转义符

```c
int k = 0;
printf("k = %%d", k); //输出为k = %d；
printf("k = %%%d", k); //输出为k = %0；
```

32.c语言中有小写的true，没有大写的true

33.逻辑与或者逻辑或的表达式，先是判断一边，若一边可以判断整个表达式为真假时，另一边不再执行。

34.

(1)编辑：也就是编写C/C++程序。

(2)预处理：相当于根据预处理指令组装新的C/C++程序。经过预处理，会产生一个没有宏定义，没有条件编译指令，没有特殊符号的输出文件，这个文件的含义同原本的文件无异，只是内容上有所不同。

(3)编译：将预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后，产生相应的汇编代码文件。

(4)链接：通过链接器将一个个目标文件（或许还会有库文件）链接在一起生成一个完整的可执行程序。 链接程序的主要工作就是将有关的目标文件彼此相连接，也就是将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。在此过程中会发现被调用的函数未被定义。

35.在C语言中，char型数据在内存中的【存储形式】是【补码】，【表示依据】是【ASCII码】

36.循环队列的相关条件和公式： 

   队尾指针是rear,队头是front，其中QueueSize为循环队列的最大长度   

(1)队空条件：rear==front   

(2)队满条件：(rear+1) %QueueSIze==front   

(3)计算队列长度：（rear-front+QueueSize）%QueueSize   

(4)入队：（rear+1）%QueueSize   

(5)出队：（front+1）%QueueSize

37.

​	    (1).对于x86，栈的增长方向是从大地址到小地址

​            (2).对于函数调用，参数的入栈顺序是从右向左

​            (3).函数调用入栈顺序是  右边参数-->左边参数-->函数返回地址

38.用链接方式存储的队列，在进行删除运算时(     )。

 A.仅修改头指针	B.仅修改尾指针	C.头、尾指针都要修改		D.头、尾指针可能都要修改

1> 当有多于一个节点时，链表表示的队列的删除操作只需要修改头指针即可，将头指针定义为head=head.next  此时不需要修改尾指针；

2> 当队列只有一个节点时，该节点既是头又是尾，如果head==tail 则需要修改尾指针将队列置空。







