The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

>  **1**: 1
>  **3**: 1,3
>  **6**: 1,2,3,6
> **10**: 1,2,5,10
> **15**: 1,3,5,15
> **21**: 1,3,7,21
> **28**: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

通过添加自然数生成三角数的序列。所以第7 个三角形数字是1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.前十个数字是：

1,3,6,10,15,21,28,36,45,55 ......

让我们列出前七个三角形数字的因子：

>  **1**：1 
>  **3**：1,3 
>  **6**：1,2,3,6 
> **10**：1,2,5,10 
> **15**：1,3,5,15 
> **21**：1,3,7,21 
> **28**：1,2， 4,7,14,28

我们可以看到28是第一个超过五个除数的三角形数。

拥有超过500个除数的第一个三角形数的值是多少？

#### 思路

1.一个正整数n被分解成质数相乘，如12 = 2(2)*3; p1(a1) *p2(a2)*p3(a3);

2.因子个数=(a1+1)(a2+1)(a3+1),如12的因子个数=(2+1)(1+1)=6;

3.F(A * B)=F(A)*F(B);

```c
#include <stdio.h>

#define max 1000000

int prime[max + 5] = {0};
int fnum[max + 5] = {0};

void init(){//素数筛框架；
	for(int i = 2; i <= max; i++){
		if(!prime[i]) {
			prime[++prime[0]] = i;
			fnum[i] = 2;//如果是素数的话，那么因子个数只有2个，Eg：3 = 1 * 3；
			}
		for(int j = 1; j <= prime[0]; j++){
			if(prime[j] * i > max) break;
			prime[prime[j] * i] = 1; //将合数标记；
			if(i % prime[j] == 0){//i有m个prime[j]相乘，fnum[i]=(...)*(m+1),再乘一个prime[j],就因该除掉(m+1),乘上(m+2);
				int m = 0,pre_i = i;
				while(pre_i % prime[j] == 0){
					m++;
					pre_i /= prime[j];	
				}
				fnum[i * prime[j]] = fnum[i] / (m + 1) * (m + 2);
				break;
			}else{
				fnum[i * prime[j]] = fnum[i] * fnum[prime[j]];//i与prime[j]互质，那么用公式F(A*B)=F(A)*F(B);
			}
		}
	}
	return ;
}

int main(){
	init();
	int n = 2, count = 0;//为了让两数互质达到降低时间复杂度的效果，由于n*(n+1)一定互质；
	while(count < 500){
		if(n & 1){//按位与运算，奇数；
			count = fnum[(n + 1) >> 1] * fnum[n];//>>1右移译为，除以2；
		}else{
			count = fnum[n >> 1] * fnum[n + 1];
		}
		++n;
	}
	printf("%d\n", n * (n + 1) / 2);

	return 0;
}
```

